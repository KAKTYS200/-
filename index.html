<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–®–∫–æ–ª–∞ —Å –ø—Ä–∏–≤–∏–¥–µ–Ω–∏—è–º–∏</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; touch-action: none; font-family: Arial; background: #000; color: white; }
        #gameCanvas { display: block; width: 100%; height: 100vh; background: #1a1a2e; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; font-size: 24px; }
        #controls { position: absolute; bottom: 20px; width: 100%; display: flex; justify-content: space-between; z-index: 100; }
        .joystick { width: 120px; height: 120px; background: rgba(255,255,255,0.2); border-radius: 50%; margin: 0 20px; touch-action: none; }
        .joystick-inner { width: 60px; height: 60px; background: rgba(255,255,255,0.5); border-radius: 50%; position: absolute; top: 30px; left: 30px; }
        #actionBtn { width: 80px; height: 80px; background: rgba(255,0,0,0.5); border-radius: 50%; margin-right: 30px; touch-action: none; }
        #gameOver, #levelComplete { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 200; }
        button { padding: 15px 30px; font-size: 20px; margin-top: 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="health">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        <div id="level">–≠—Ç–∞–∂: 1</div>
        <div id="keys">üîë: 0</div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div id="controls">
        <div class="joystick" id="moveJoystick"><div class="joystick-inner"></div></div>
        <div id="actionBtn">–î–µ–π—Å—Ç–≤–∏–µ</div>
    </div>
    
    <div id="gameOver">
        <h1>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!</h1>
        <p>–í–∞—Å –ø–æ–π–º–∞–ª –∑–ª–æ–π —É—á–∏—Ç–µ–ª—å...</p>
        <button onclick="resetGame()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
    </div>
    
    <div id="levelComplete">
        <h1>–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω!</h1>
        <p>–í—ã –Ω–∞—à–ª–∏ –≤—ã—Ö–æ–¥ —Å —ç—Ç–æ–≥–æ —ç—Ç–∞–∂–∞!</p>
        <button onclick="nextLevel()">–°–ª–µ–¥—É—é—â–∏–π —ç—Ç–∞–∂</button>
    </div>

    <script>
        // –û—Å–Ω–æ–≤–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const ui = { 
            health: document.getElementById('health'), 
            level: document.getElementById('level'), 
            keys: document.getElementById('keys') 
        };
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä—ã
        const settings = {
            cellSize: 300,
            roomSize: { min: 12, max: 18 },
            corridorWidth: 50,
            zoom: 1.5,
            baseEnemySpeed: 0.8,
            enemySpeedIncrease: 0.05
        };
        
        // –¢–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è —Ñ–æ–Ω–∞
        const backgroundPattern = (() => {
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = 100;
            patternCanvas.height = 100;
            const patternCtx = patternCanvas.getContext('2d');
            
            // –†–∏—Å—É–µ–º —à–∫–æ–ª—å–Ω—É—é –¥–æ—Å–∫—É
            patternCtx.fillStyle = '#1a1a2e';
            patternCtx.fillRect(0, 0, 100, 100);
            
            // –†–∏—Å—É–µ–º –ª–∏–Ω–∏–∏ –∫–∞–∫ –Ω–∞ —Ç–µ—Ç—Ä–∞–¥–Ω–æ–º –ª–∏—Å—Ç–µ
            patternCtx.strokeStyle = 'rgba(255,255,255,0.05)';
            patternCtx.lineWidth = 1;
            for (let y = 0; y < 100; y += 10) {
                patternCtx.beginPath();
                patternCtx.moveTo(0, y);
                patternCtx.lineTo(100, y);
                patternCtx.stroke();
            }
            
            return ctx.createPattern(patternCanvas, 'repeat');
        })();
        
        // –ò–≥—Ä–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã
        let player = {
            x: 100, y: 100, size: 18, speed: 4, health: 3, 
            dir: { x: 0, y: 0 }, invincible: 0, color: '#4169E1',
            slide: { x: 0, y: 0 }
        };
        
        let level = {
            current: 1,
            rooms: [],
            corridors: [],
            enemies: [],
            items: [],
            furniture: [],
            exit: null
        };
        
        // –ö–∞–º–µ—Ä–∞
        let camera = { x: 0, y: 0 };
        
        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        let joystick = { active: false, x: 0, y: 0 };
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        function initGame() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            generateLevel();
            setupControls();
            gameLoop();
        }
        
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É—Ä–æ–≤–Ω—è
        function generateLevel() {
            level.rooms = [];
            level.corridors = [];
            level.enemies = [];
            level.items = [];
            level.furniture = [];
            
            // –°–æ–∑–¥–∞–µ–º —Å–µ—Ç–∫—É –∫–æ–º–Ω–∞—Ç
            const gridSize = 5;
            const grid = Array(gridSize).fill().map(() => Array(gridSize).fill(null));
            
            // –°—Ç–∞—Ä—Ç–æ–≤–∞—è –∫–æ–º–Ω–∞—Ç–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ
            const startRoom = createRoom(Math.floor(gridSize/2), Math.floor(gridSize/2));
            grid[startRoom.x][startRoom.y] = startRoom;
            level.rooms.push(startRoom);
            
            // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –ø—Ä–æ—Ö–æ–¥ –≤–æ –≤—Å–µ –∫–æ–º–Ω–∞—Ç—ã —Å –∫–æ—Ä–∏–¥–æ—Ä–∞–º–∏
            let roomsToExpand = [startRoom];
            while (roomsToExpand.length > 0 && level.rooms.length < 4 + level.current) {
                const room = roomsToExpand.shift();
                const directions = shuffleArray([{dx:-1,dy:0},{dx:1,dy:0},{dx:0,dy:-1},{dx:0,dy:1}]);
                
                for (const dir of directions) {
                    const nx = room.x + dir.dx, ny = room.y + dir.dy;
                    if (nx >=0 && nx < gridSize && ny >=0 && ny < gridSize && !grid[nx][ny]) {
                        const newRoom = createRoom(nx, ny);
                        grid[nx][ny] = newRoom;
                        level.rooms.push(newRoom);
                        roomsToExpand.push(newRoom);
                        
                        // –°–æ–∑–¥–∞–µ–º –∫–æ—Ä–∏–¥–æ—Ä –º–µ–∂–¥—É –∫–æ–º–Ω–∞—Ç–∞–º–∏
                        createCorridor(room, newRoom, dir);
                        break;
                    }
                }
            }
            
            // –í—ã—Ö–æ–¥ –≤ –¥–∞–ª—å–Ω–µ–π –∫–æ–º–Ω–∞—Ç–µ
            const exitRoom = level.rooms[level.rooms.length-1];
            level.exit = {
                x: exitRoom.x * settings.cellSize + exitRoom.w * 15,
                y: exitRoom.y * settings.cellSize + exitRoom.h * 15,
                size: 25
            };
            
            // –ö–ª—é—á–∏ (1 –Ω–∞ 3 –∫–æ–º–Ω–∞—Ç—ã)
            const keyCount = Math.max(1, Math.floor(level.rooms.length / 3));
            for (let i = 0; i < keyCount; i++) {
                const room = level.rooms[(i+1) % level.rooms.length];
                level.items.push({
                    x: room.x * settings.cellSize + 50 + Math.random() * (room.w * 20 - 100),
                    y: room.y * settings.cellSize + 50 + Math.random() * (room.h * 20 - 100),
                    size: 15, type: 'key'
                });
            }
            
            // –ú–µ–±–µ–ª—å –≤ –∫–æ–º–Ω–∞—Ç–∞—Ö (1-2 –ø—Ä–µ–¥–º–µ—Ç–∞ –Ω–∞ –∫–æ–º–Ω–∞—Ç—É)
            level.rooms.forEach(room => {
                const furnitureCount = 1 + Math.floor(Math.random() * 2);
                for (let i = 0; i < furnitureCount; i++) {
                    const type = ['desk', 'cabinet', 'chair', 'table'][Math.floor(Math.random() * 4)];
                    level.furniture.push(createFurniture(room, type));
                }
            });
            
            // –í—Ä–∞–≥–∏ (1 + —É—Ä–æ–≤–µ–Ω—å)
            for (let i = 0; i < 1 + level.current; i++) {
                const room = level.rooms[1 + i % (level.rooms.length-1)];
                level.enemies.push(createEnemy(
                    room.x * settings.cellSize + 50 + Math.random() * (room.w * 20 - 100),
                    room.y * settings.cellSize + 50 + Math.random() * (room.h * 20 - 100),
                    settings.baseEnemySpeed + (level.current-1) * settings.enemySpeedIncrease
                ));
            }
            
            // –ò–≥—Ä–æ–∫ –≤ —Å—Ç–∞—Ä—Ç–æ–≤–æ–π –∫–æ–º–Ω–∞—Ç–µ
            player.x = startRoom.x * settings.cellSize + startRoom.w * 15;
            player.y = startRoom.y * settings.cellSize + startRoom.h * 15;
            player.health = 3;
            player.keys = 0;
            player.slide = { x: 0, y: 0 };
            
            updateUI();
        }
        
        function createRoom(x, y) {
            return {
                x, y,
                w: settings.roomSize.min + Math.floor(Math.random() * (settings.roomSize.max - settings.roomSize.min)),
                h: settings.roomSize.min + Math.floor(Math.random() * (settings.roomSize.max - settings.roomSize.min)),
                centerX: 0, centerY: 0
            };
        }
        
        function createCorridor(room1, room2, dir) {
            // –í—ã—á–∏—Å–ª—è–µ–º —Ü–µ–Ω—Ç—Ä—ã –∫–æ–º–Ω–∞—Ç
            room1.centerX = room1.x * settings.cellSize + room1.w * 10;
            room1.centerY = room1.y * settings.cellSize + room1.h * 10;
            room2.centerX = room2.x * settings.cellSize + room2.w * 10;
            room2.centerY = room2.y * settings.cellSize + room2.h * 10;
            
            // –°–æ–∑–¥–∞–µ–º –∫–æ—Ä–∏–¥–æ—Ä –º–µ–∂–¥—É –∫–æ–º–Ω–∞—Ç–∞–º–∏
            const corridor = {
                x1: room1.centerX, y1: room1.centerY,
                x2: room2.centerX, y2: room2.centerY,
                width: settings.corridorWidth
            };
            
            // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –ø–æ–∑–∏—Ü–∏–∏ —á—Ç–æ–±—ã —Å–æ–µ–¥–∏–Ω–∏—Ç—å –∫–æ–º–Ω–∞—Ç—ã
            if (dir.dx !== 0) { // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π –∫–æ—Ä–∏–¥–æ—Ä
                corridor.y1 = corridor.y2 = (room1.centerY + room2.centerY) / 2;
                corridor.x1 = dir.dx > 0 ? 
                    room1.x * settings.cellSize + room1.w * 20 : 
                    room1.x * settings.cellSize;
                corridor.x2 = dir.dx > 0 ? 
                    room2.x * settings.cellSize : 
                    room2.x * settings.cellSize + room2.w * 20;
            } else { // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –∫–æ—Ä–∏–¥–æ—Ä
                corridor.x1 = corridor.x2 = (room1.centerX + room2.centerX) / 2;
                corridor.y1 = dir.dy > 0 ? 
                    room1.y * settings.cellSize + room1.h * 20 : 
                    room1.y * settings.cellSize;
                corridor.y2 = dir.dy > 0 ? 
                    room2.y * settings.cellSize : 
                    room2.y * settings.cellSize + room2.h * 20;
            }
            
            level.corridors.push(corridor);
            return corridor;
        }
        
        function createFurniture(room, type) {
            const size = {
                desk: {w: 40, h: 80},
                cabinet: {w: 60, h: 100},
                chair: {w: 30, h: 30},
                table: {w: 80, h: 80}
            }[type];
            
            return {
                x: room.x * settings.cellSize + 40 + Math.random() * (room.w * 20 - 80 - size.w),
                y: room.y * settings.cellSize + 40 + Math.random() * (room.h * 20 - 80 - size.h),
                w: size.w,
                h: size.h,
                type: type
            };
        }
        
        function createEnemy(x, y, speed) {
            return {
                x, y, size: 20, speed: speed,
                dir: Math.random() * Math.PI * 2, timer: 60,
                state: 'wander', color: '#800000',
                targetX: 0, targetY: 0, delay: Math.random() * 60,
                slide: {x: 0, y: 0}
            };
        }
        
        // –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        function update() {
            // –î–≤–∏–∂–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ —Å —É—á–µ—Ç–æ–º —Å–∫–æ–ª—å–∂–µ–Ω–∏—è
            if (joystick.active) {
                const len = Math.sqrt(joystick.x * joystick.x + joystick.y * joystick.y);
                if (len > 0) {
                    player.dir.x = joystick.x/len;
                    player.dir.y = joystick.y/len;
                }
            }
            
            // –ü–ª–∞–≤–Ω–æ–µ —Å–∫–æ–ª—å–∂–µ–Ω–∏–µ –ø—Ä–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–∏
            player.slide.x *= 0.9;
            player.slide.y *= 0.9;
            
            const moveX = player.dir.x * player.speed + player.slide.x;
            const moveY = player.dir.y * player.speed + player.slide.y;
            
            // –ù–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –∏–≥—Ä–æ–∫–∞
            let newX = player.x + moveX;
            let newY = player.y + moveY;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –≤ –∫–æ–º–Ω–∞—Ç–µ –∏–ª–∏ –∫–æ—Ä–∏–¥–æ—Ä–µ –∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å –º–µ–±–µ–ª—å—é
            const canMove = canMoveTo(newX, newY, player.size);
            
            if (canMove) {
                player.x = newX;
                player.y = newY;
            } else {
                // –≠—Ñ—Ñ–µ–∫—Ç —Å–∫–æ–ª—å–∂–µ–Ω–∏—è –≤–¥–æ–ª—å —Å—Ç–µ–Ω
                if (canMoveTo(newX, player.y, player.size)) {
                    player.x = newX;
                    player.slide.y = moveY * 0.5;
                } else if (canMoveTo(player.x, newY, player.size)) {
                    player.y = newY;
                    player.slide.x = moveX * 0.5;
                } else {
                    player.slide.x = moveX * 0.3;
                    player.slide.y = moveY * 0.3;
                }
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
            camera.x = player.x - canvas.width / (2 * settings.zoom);
            camera.y = player.y - canvas.height / (2 * settings.zoom);
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
            level.enemies.forEach(enemy => {
                if (enemy.delay > 0) {
                    enemy.delay--;
                    return;
                }
                
                enemy.timer--;
                
                // –õ–æ–≥–∏–∫–∞ –≤—Ä–∞–≥–∞
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distToPlayer = Math.sqrt(dx*dx + dy*dy);
                
                if (distToPlayer < 30) { // –ê—Ç–∞–∫–∞
                    enemy.state = 'attack';
                    if (!player.invincible) {
                        player.health--;
                        player.invincible = 60;
                        updateUI();
                        if (player.health <= 0) gameOver();
                    }
                } 
                else if (distToPlayer < 250 || enemy.state === 'chase') { // –ü—Ä–µ—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ
                    enemy.state = 'chase';
                    enemy.dir = Math.atan2(dy, dx);
                    enemy.timer = 60;
                } 
                else { // –ë–ª—É–∂–¥–∞–Ω–∏–µ
                    enemy.state = 'wander';
                    if (enemy.timer <= 0) {
                        // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é —Ç–æ—á–∫—É –≤ —Ç–µ–∫—É—â–µ–π –∫–æ–º–Ω–∞—Ç–µ
                        const room = getCurrentRoom(enemy);
                        if (room) {
                            enemy.targetX = room.x * settings.cellSize + 50 + Math.random() * (room.w * 20 - 100);
                            enemy.targetY = room.y * settings.cellSize + 50 + Math.random() * (room.h * 20 - 100);
                            enemy.dir = Math.atan2(enemy.targetY - enemy.y, enemy.targetX - enemy.x);
                        }
                        enemy.timer = 120 + Math.random() * 120;
                    }
                }
                
                // –ü–ª–∞–≤–Ω–æ–µ —Å–∫–æ–ª—å–∂–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤ –ø—Ä–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–∏
                enemy.slide.x *= 0.9;
                enemy.slide.y *= 0.9;
                
                // –î–≤–∏–∂–µ–Ω–∏–µ –≤—Ä–∞–≥–∞
                const enemyMoveX = Math.cos(enemy.dir) * enemy.speed + enemy.slide.x;
                const enemyMoveY = Math.sin(enemy.dir) * enemy.speed + enemy.slide.y;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞, –º–æ–∂–µ—Ç –ª–∏ –≤—Ä–∞–≥ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å—Å—è
                const newEnemyX = enemy.x + enemyMoveX;
                const newEnemyY = enemy.y + enemyMoveY;
                
                const enemyCanMove = canMoveTo(newEnemyX, newEnemyY, enemy.size);
                
                if (enemyCanMove) {
                    enemy.x = newEnemyX;
                    enemy.y = newEnemyY;
                } else {
                    // –≠—Ñ—Ñ–µ–∫—Ç —Å–∫–æ–ª—å–∂–µ–Ω–∏—è –¥–ª—è –≤—Ä–∞–≥–æ–≤
                    if (canMoveTo(newEnemyX, enemy.y, enemy.size)) {
                        enemy.x = newEnemyX;
                        enemy.slide.y = enemyMoveY * 0.5;
                    } else if (canMoveTo(enemy.x, newEnemyY, enemy.size)) {
                        enemy.y = newEnemyY;
                        enemy.slide.x = enemyMoveX * 0.5;
                    } else {
                        enemy.slide.x = enemyMoveX * 0.3;
                        enemy.slide.y = enemyMoveY * 0.3;
                        enemy.dir = Math.random() * Math.PI * 2;
                    }
                }
            });
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–µ–¥–º–µ—Ç–æ–≤
            for (let i = level.items.length-1; i >= 0; i--) {
                if (checkCollision(player, level.items[i])) {
                    if (level.items[i].type === 'key') player.keys++;
                    level.items.splice(i, 1);
                    updateUI();
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã—Ö–æ–¥–∞
            if (level.exit && checkCollision(player, level.exit) && 
                player.keys >= Math.max(1, Math.floor(level.rooms.length / 3))) {
                levelComplete();
            }
            
            // –ù–µ—É—è–∑–≤–∏–º–æ—Å—Ç—å –ø–æ—Å–ª–µ —É–¥–∞—Ä–∞
            if (player.invincible > 0) player.invincible--;
        }
        
        function canMoveTo(x, y, size) {
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –≤ –∫–æ–º–Ω–∞—Ç–µ –∏–ª–∏ –∫–æ—Ä–∏–¥–æ—Ä–µ
            if (!isInRoomOrCorridor(x, y)) return false;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å –º–µ–±–µ–ª—å—é
            for (const item of level.furniture) {
                if (x + size > item.x && x - size < item.x + item.w &&
                    y + size > item.y && y - size < item.y + item.h) {
                    return false;
                }
            }
            
            return true;
        }
        
        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞
        function render() {
            // –§–æ–Ω - —à–∫–æ–ª—å–Ω–∞—è –¥–æ—Å–∫–∞
            ctx.fillStyle = backgroundPattern;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∫–∞–º–µ—Ä—ã
            ctx.save();
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.scale(settings.zoom, settings.zoom);
            ctx.translate(-camera.x - canvas.width/(2*settings.zoom), -camera.y - canvas.height/(2*settings.zoom));
            
            // –ö–æ—Ä–∏–¥–æ—Ä—ã (—Ä–∏—Å—É–µ–º –ø–µ—Ä–≤—ã–º–∏, —á—Ç–æ–±—ã –∫–æ–º–Ω–∞—Ç—ã –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–ª–∏ –∏—Ö)
            ctx.fillStyle = '#2a2a3a';
            level.corridors.forEach(corridor => {
                if (corridor.x1 === corridor.x2) { // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –∫–æ—Ä–∏–¥–æ—Ä
                    ctx.fillRect(
                        corridor.x1 - corridor.width/2,
                        Math.min(corridor.y1, corridor.y2),
                        corridor.width,
                        Math.abs(corridor.y1 - corridor.y2)
                    );
                } else { // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π –∫–æ—Ä–∏–¥–æ—Ä
                    ctx.fillRect(
                        Math.min(corridor.x1, corridor.x2),
                        corridor.y1 - corridor.width/2,
                        Math.abs(corridor.x1 - corridor.x2),
                        corridor.width
                    );
                }
            });
            
            // –ö–æ–º–Ω–∞—Ç—ã
            ctx.fillStyle = '#333344';
            level.rooms.forEach(room => {
                ctx.fillRect(room.x * settings.cellSize, room.y * settings.cellSize, room.w * 20, room.h * 20);
                ctx.strokeStyle = '#555566';
                ctx.lineWidth = 3;
                ctx.strokeRect(room.x * settings.cellSize, room.y * settings.cellSize, room.w * 20, room.h * 20);
            });
            
            // –ú–µ–±–µ–ª—å
            level.furniture.forEach(item => {
                ctx.fillStyle = '#654321';
                ctx.fillRect(item.x, item.y, item.w, item.h);
                
                // –î–µ—Ç–∞–ª–∏ –º–µ–±–µ–ª–∏
                ctx.strokeStyle = '#543210';
                ctx.lineWidth = 2;
                ctx.strokeRect(item.x, item.y, item.w, item.h);
                
                if (item.type === 'desk') {
                    // –†–∏—Å—É–µ–º —è—â–∏–∫–∏ —Å—Ç–æ–ª–∞
                    ctx.fillStyle = '#543210';
                    ctx.fillRect(item.x + 5, item.y + 5, 10, item.h - 10);
                    ctx.fillRect(item.x + item.w - 15, item.y + 5, 10, item.h - 10);
                } else if (item.type === 'cabinet') {
                    // –†–∏—Å—É–µ–º –¥–≤–µ—Ä—Ü—ã —à–∫–∞—Ñ–∞
                    ctx.fillStyle = '#543210';
                    ctx.fillRect(item.x + 5, item.y + 5, item.w - 10, 40);
                    ctx.fillRect(item.x + 5, item.y + 55, item.w - 10, 40);
                } else if (item.type === 'chair') {
                    // –°–ø–∏–Ω–∫–∞ —Å—Ç—É–ª–∞
                    ctx.fillStyle = '#543210';
                    ctx.fillRect(item.x + 5, item.y + 5, item.w - 10, 5);
                } else if (item.type === 'table') {
                    // –ù–æ–∂–∫–∏ —Å—Ç–æ–ª–∞
                    ctx.fillStyle = '#543210';
                    ctx.fillRect(item.x + 5, item.y + 5, 10, 10);
                    ctx.fillRect(item.x + item.w - 15, item.y + 5, 10, 10);
                    ctx.fillRect(item.x + 5, item.y + item.h - 15, 10, 10);
                    ctx.fillRect(item.x + item.w - 15, item.y + item.h - 15, 10, 10);
                }
            });
            
            // –ü—Ä–µ–¥–º–µ—Ç—ã
            level.items.forEach(item => {
                if (item.type === 'key') {
                    // –ê–Ω–∏–º–∞—Ü–∏—è –∫–ª—é—á–∞
                    ctx.save();
                    ctx.translate(item.x, item.y);
                    ctx.rotate(Date.now() / 800);
                    
                    ctx.fillStyle = 'gold';
                    ctx.beginPath();
                    ctx.arc(0, 0, item.size, 0, Math.PI*2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#daa520';
                    ctx.fillRect(-4, -item.size, 8, item.size);
                    
                    ctx.restore();
                }
            });
            
            // –í—Ä–∞–≥–∏ (—É—á–∏—Ç–µ–ª—è)
            level.enemies.forEach(enemy => {
                if (enemy.delay > 0) return;
                
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                
                // –¢–µ–Ω—å
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.beginPath();
                ctx.arc(0, 5, enemy.size, 0, Math.PI*2);
                ctx.fill();
                
                // –¢–µ–ª–æ (—Ö–∞–ª–∞—Ç —É—á–∏—Ç–µ–ª—è)
                ctx.fillStyle = enemy.state === 'chase' ? '#a00' : '#800';
                ctx.beginPath();
                ctx.moveTo(-enemy.size, 0);
                ctx.lineTo(enemy.size, 0);
                ctx.lineTo(enemy.size - 5, enemy.size);
                ctx.lineTo(-enemy.size + 5, enemy.size);
                ctx.closePath();
                ctx.fill();
                
                // –ì–æ–ª–æ–≤–∞
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(0, -enemy.size/2, enemy.size/2, 0, Math.PI*2);
                ctx.fill();
                
                // –ì–ª–∞–∑–∞
                const eyeOffset = enemy.state === 'attack' ? 0 : Math.sin(Date.now()/400) * 3;
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(-3 + eyeOffset, -enemy.size/2, 3, 0, Math.PI*2);
                ctx.arc(3 + eyeOffset, -enemy.size/2, 3, 0, Math.PI*2);
                ctx.fill();
                
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(-3 + eyeOffset, -enemy.size/2, 1.5, 0, Math.PI*2);
                ctx.arc(3 + eyeOffset, -enemy.size/2, 1.5, 0, Math.PI*2);
                ctx.fill();
                
                // –†–æ—Ç
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                if (enemy.state === 'attack') {
                    ctx.arc(0, -enemy.size/4, 3, 0, Math.PI);
                } else {
                    ctx.moveTo(-2, -enemy.size/4);
                    ctx.lineTo(2, -enemy.size/4);
                }
                ctx.stroke();
                
                // –£–∫–∞–∑–∫–∞
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(enemy.size, 0);
                ctx.lineTo(enemy.size + 20 * Math.cos(enemy.dir), 20 * Math.sin(enemy.dir));
                ctx.stroke();
                
                ctx.restore();
            });
            
            // –í—ã—Ö–æ–¥
            if (level.exit) {
                ctx.fillStyle = player.keys >= Math.max(1, Math.floor(level.rooms.length/3)) ? '#0F0' : '#F00';
                ctx.beginPath();
                ctx.arc(level.exit.x, level.exit.y, level.exit.size, 0, Math.PI*2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('–í–´–•–û–î', level.exit.x, level.exit.y);
            }
            
            // –ò–≥—Ä–æ–∫ (—É—á–µ–Ω–∏–∫)
            const flash = player.invincible > 0 && Math.floor(player.invincible/5) % 2 === 0;
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // –¢–µ–Ω—å
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.arc(0, 5, player.size, 0, Math.PI*2);
            ctx.fill();
            
            // –¢–µ–ª–æ (—à–∫–æ–ª—å–Ω–∞—è —Ñ–æ—Ä–º–∞)
            ctx.fillStyle = flash ? '#FFF' : '#4169E1';
            ctx.beginPath();
            ctx.moveTo(-player.size/2, player.size/2);
            ctx.lineTo(player.size/2, player.size/2);
            ctx.lineTo(player.size/2, -player.size/3);
            ctx.lineTo(-player.size/2, -player.size/3);
            ctx.closePath();
            ctx.fill();
            
            // –ì–æ–ª–æ–≤–∞
            ctx.fillStyle = flash ? '#FFF' : '#FFD700';
            ctx.beginPath();
            ctx.arc(0, -player.size/2, player.size/2, 0, Math.PI*2);
            ctx.fill();
            
            // –ì–ª–∞–∑–∞
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-3, -player.size/2, 2, 0, Math.PI*2);
            ctx.arc(3, -player.size/2, 2, 0, Math.PI*2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(-3 + player.dir.x * 2, -player.size/2 + player.dir.y * 2, 1, 0, Math.PI*2);
            ctx.arc(3 + player.dir.x * 2, -player.size/2 + player.dir.y * 2, 1, 0, Math.PI*2);
            ctx.fill();
            
            // –†–æ—Ç
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, -player.size/3, 2, 0, Math.PI);
            ctx.stroke();
            
            // –†—é–∫–∑–∞–∫
            ctx.fillStyle = '#654321';
            ctx.fillRect(-player.size - 3, -player.size/3, 6, player.size);
            
            ctx.restore();
            
            ctx.restore();
        }
        
        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        function isInRoomOrCorridor(x, y) {
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–º–Ω–∞—Ç
            if (level.rooms.some(room => 
                x >= room.x * settings.cellSize && 
                x <= room.x * settings.cellSize + room.w * 20 &&
                y >= room.y * settings.cellSize && 
                y <= room.y * settings.cellSize + room.h * 20
            )) return true;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä–∏–¥–æ—Ä–æ–≤
            return level.corridors.some(corridor => {
                if (corridor.x1 === corridor.x2) { // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –∫–æ—Ä–∏–¥–æ—Ä
                    return x >= corridor.x1 - corridor.width/2 && 
                           x <= corridor.x1 + corridor.width/2 && 
                           y >= Math.min(corridor.y1, corridor.y2) && 
                           y <= Math.max(corridor.y1, corridor.y2);
                } else { // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π –∫–æ—Ä–∏–¥–æ—Ä
                    return y >= corridor.y1 - corridor.width/2 && 
                           y <= corridor.y1 + corridor.width/2 && 
                           x >= Math.min(corridor.x1, corridor.x2) && 
                           x <= Math.max(corridor.x1, corridor.x2);
                }
            });
        }
        
        function getCurrentRoom(entity) {
            return level.rooms.find(room => 
                entity.x >= room.x * settings.cellSize && 
                entity.x <= room.x * settings.cellSize + room.w * 20 &&
                entity.y >= room.y * settings.cellSize && 
                entity.y <= room.y * settings.cellSize + room.h * 20
            );
        }
        
        function checkCollision(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            return dist < (a.size || 10) + (b.size || 10);
        }
        
        function shuffleArray(array) {
            for (let i = array.length-1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i+1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        function updateUI() {
            ui.health.textContent = '‚ù§Ô∏è'.repeat(player.health);
            ui.level.textContent = `–≠—Ç–∞–∂: ${level.current}`;
            ui.keys.textContent = `üîë: ${player.keys}`;
        }
        
        function gameOver() {
            document.getElementById('gameOver').style.display = 'flex';
        }
        
        function levelComplete() {
            document.getElementById('levelComplete').style.display = 'flex';
        }
        
        function resetGame() {
            level.current = 1;
            document.getElementById('gameOver').style.display = 'none';
            generateLevel();
        }
        
        function nextLevel() {
            level.current++;
            document.getElementById('levelComplete').style.display = 'none';
            generateLevel();
        }
        
        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        function setupControls() {
            const joystickEl = document.getElementById('moveJoystick');
            const inner = joystickEl.querySelector('.joystick-inner');
            
            joystickEl.addEventListener('touchstart', e => {
                e.preventDefault();
                const rect = joystickEl.getBoundingClientRect();
                joystick.active = true;
                joystick.startX = rect.left + rect.width/2;
                joystick.startY = rect.top + rect.height/2;
                updateJoystick(e.touches[0]);
            });
            
            document.addEventListener('touchmove', e => {
                if (joystick.active) updateJoystick(e.touches[0]);
            });
            
            document.addEventListener('touchend', () => {
                joystick.active = false;
                joystick.x = joystick.y = 0;
                player.dir = { x: 0, y: 0 };
                inner.style.transform = 'translate(0, 0)';
            });
            
            function updateJoystick(touch) {
                joystick.x = touch.clientX - joystick.startX;
                joystick.y = touch.clientY - joystick.startY;
                
                const dist = Math.sqrt(joystick.x*joystick.x + joystick.y*joystick.y);
                const max = 50;
                
                if (dist > max) {
                    joystick.x = (joystick.x/dist)*max;
                    joystick.y = (joystick.y/dist)*max;
                }
                
                inner.style.transform = `translate(${joystick.x}px, ${joystick.y}px)`;
            }
        }
        
        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
        window.addEventListener('load', initGame);
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
  </html>
